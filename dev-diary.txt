2/4/19

at long last, chapter 13 is behind me and i'm about ready to start

reading through https://doc.rust-lang.org/std/iter/trait.Iterator.html before i begin

the bit about using collect() to collect a list of Results into a Result of lists is interesting

btw here are the vim keybinds i've set up that i need to remember

gd - go to definition
gs - go to definition in a split
,gd - look up documentation
C-x C-o - completion (could this work with C-p instead?)

useful-looking methods aside from the usual FP ones:
* partition
* inspect
* filter_map
* by_ref
* all, any
* find
* find_map
* position, rposition
* max_by_key, max_by, min_by_key, min_by
* rev
* cloned

things i know by different names:
* `flat_map` is clj `mapcat`
* `scan` is clj `reductions`
* `skip` is clj `drop`
* `fold` is clj `reduce`
* `partition` is yelp_lib.iteration `winnow`

things to watch out for:
some of these methods (particularly map, filter, take_while, skip_while, etc)
have this in their documentation (copy-pasting follows):

Because the closure passed to filter() takes a reference, and many iterators iterate over
references, this leads to a possibly confusing situation, where the type of the closure is a double reference.

```
let a = [0, 1, 2];

let mut iter = a.into_iter().filter(|x| **x > 1); // need two *s!

assert_eq!(iter.next(), Some(&2));
assert_eq!(iter.next(), None);
```

so let's just keep an eye out for that.

TODO read through https://doc.rust-lang.org/std/index.html

ok here goes

1a: sum all the numbers

pretty straightforward

1b is straightforward too but i'm confused about this:

let set: HashSet<_> = [1, 2, 3].iter().cloned().collect();
assert_eq!(set.contains(&1), true);
assert_eq!(set.contains(&4), false);

why does set.contains(&1) have to have the &?
TODO ask peter

https://www.forrestthewoods.com/blog/learning-rust-via-advent-of-code/
has a good list of iterator methods and useful crates

mentions https://crates.io/crates/nom and https://crates.io/crates/pest as being
possibly useful for day24

recommends https://github.com/Amanieu/hashbrown

let's try it out!
2x speedup!!

oh wow nice i hadn't tried building in release mode - 0.01 seconds for the whole thing atm

ok so i went through a few rounds of changes for 2b

originally i had this

fn two_b() -> String {
    let contents = fs::read_to_string("src/inputs/2.txt").unwrap();
    let lines: Vec<&str> = contents.lines().collect();

    for (i, line) in lines.iter().enumerate() {
        for other_line in lines.iter().skip(i) {
            let diff_positions = differing_character_positions(line, other_line);
            if diff_positions.iter().count() == 1 {
                let mut ret = String::new();
                for (i, character) in line.chars().enumerate() {
                    if i != diff_positions[0] {
                        ret.push(character);
                    }
                }

                return ret;
            }
        }
    }

    "unreachable".to_string()
}

then i went crazy with iterator methods for fun and got this

fn two_b() -> String {
    let contents = fs::read_to_string("src/inputs/2.txt").unwrap();
    let lines: Vec<&str> = contents.lines().collect();

    let (box_a, box_b) = lines
        .iter()
        .enumerate()
        .flat_map(|(i, line)| {
            lines
                .iter()
                .skip(i)
                .map(move |other_line| (line, other_line))
        })
        .find(|(line, other_line)| {
            differing_character_positions(line, other_line)
                .iter()
                .count()
                == 1
        })
        .unwrap();

    let differing_index = differing_character_positions(box_a, box_b)[0];

    let mut ret = String::new();
    for (i, character) in box_a.chars().enumerate() {
        if i != differing_index {
            ret.push(character);
        }
    }

    return ret;
}

but i was sure that there must be some way to improve that - in particular, the bit where
i was like trying to zip lines against itself (or get, like, a one-way cartesian product?)
felt like it must be implemented in itertools somewhere
and lo and behold, .combinations(2) does exactly what i wanted
except that it puts things in a Vec, so i have to put the two strings into a tuple
so i can destructure them later
and then we get this

fn two_b() -> String {
    let contents = fs::read_to_string("src/inputs/2.txt").unwrap();
    let lines: Vec<&str> = contents.lines().collect();

    let (box_a, box_b) = lines
        .iter()
        .combinations(2)
        .map(|pair| (pair[0], pair[1]))
        .find(|(box_a, box_b)| {
            differing_character_positions(box_a, box_b)
                .iter()
                .count()
                == 1
        })
        .unwrap();

    let differing_index = differing_character_positions(box_a, box_b)[0];

    let mut ret = String::new();
    for (i, character) in box_a.chars().enumerate() {
        if i != differing_index {
            ret.push(character);
        }
    }

    return ret;
}

i still feel like the bit at the end where we make a string that's got all the chars
except for one at a particular index must be improvable somehow, but it's not obvious to me how

eh, it turns out this does the trick:

    box_a
        .chars()
        .enumerate()
        .filter(|(i, _)| *i != differing_index)
        .map(|(_, character)| character)
        .collect::<String>()

but the forloop approach is simpler so i'll stick with that.

======

2/5/19

3a+3b were easy

starting 4a - first challenge is to sort the log entries chronologically

https://crates.io/crates/chrono is apparently a good crate for time stuff

also, HN says:

`
For sorting sequential fields you can chain comparisons with .then():
    struct Date {
        year: u32,
        month: u32,
        day: u32,
    }

    let mut vec: Vec<Date> = Vec::new();

    vec.sort_by(|a,b| {
       a.year.cmp(&b.year)
        .then(a.month.cmp(&b.month))
        .then(a.day.cmp(&b.day))
    });
Alternatively you can derive PartialEq, PartialOrd, Eq and Ord for your struct, which will
produce a lexicographic ordering based on the top-to-bottom declaration order of the struct's members:
    #[derive(PartialEq, PartialOrd, Eq, Ord)]
    struct Date {
        year: u32,
        month: u32,
        day: u32,
    }

`
`
Or you can use sort_by_key and extract the relevant sorting key as a tuple (or any other Ord structure) e.g.
    vec.sort_by_key(|d| (d.year, d.month, d.day))
sort_by is more flexible as it works fine with borrows, but when sorting on a series of integer values or references sort_by_key is great.
`

starting off with chrono

====

2/6/19

trying out vs code
seems reasonable so far
had to turn off intellisense (autocomplete) in text files just now,
https://stackoverflow.com/questions/38832753/how-to-disable-intellisense-in-vs-code-for-markdown was really useful for that

USEFUL KEYBOARD SHORTCUTS I WILL NEED TO MEMORIZE
gd - go to definition
gh - "equivalent to hovering your mouse over wherever the cursor is. Handy for seeing types and error messages without reaching for the mouse!"
Cmd-K Cmd-Z - zen mode (fullscreen)
Cmd-shift-, - go one tab to the left
Cmd-shift-. - go one tab to the right
Cmd-t - open terminal pane
Cmd-shift-up - toggle maximized/regular pane size

less often:
Cmd-shift-X - show extensions
Cmd-shift-F - show search
Cmd-shift-e - show explorer
Cmd-shift-U - show output pane
Cmd-shift-m - show problems pane
Cmd-b - show/hide sidebar

full list at https://code.visualstudio.com/shortcuts/keyboard-shortcuts-macos.pdf

TODO consider learning about vim-easymotion, https://github.com/easymotion/vim-easymotion
vs code vim bindings plugin has support for it

TODO use dbg!() instead of println for inspecting data

TODO read the edition guide after the book: https://rust-lang-nursery.github.io/edition-guide/introduction.html

TODO read https://blog.burntsushi.net/rust-error-handling/

https://www.ragona.com/posts/learning_rust_2019 talks about Box, i'm sure i'll understand this more
once i've gotten to that part of the book

====

2/7/19

spent some time with flamer trying to improve the speed of 5, didn't make much progress, just gonna skip it for now
TODO read through burntsushi / forrestthewoods' solutions after i'm done with aoc, see how they did day 5
TODO concurrency perhaps!

ok so i've been having a slight amount of trouble with chapter 15, let's write down my understanding of these things

* Box<T> is for storing data on the heap instead of the stack; one common reason you might want to do that
is when storing a piece of data whose size can't be known at compile time.
* Rc<T> is for storing data that can have multiple owners. it's used to make sure that the data is correctly
and automatically dropped once its owners have all gone away.
* RefCell<T> is for situations where you want to mutate data in ways/places that you're sure are safe,
but which the compiler can't tell are safe via static analysis. the compiler enforces ownership/borrowing rules
at compile time, which is good for a bunch of reasons that are obvious to me (catch errors earlier, less overhead, etc).
RefCell<T> enforces ownership/borrowing rules at runtime, which is bad because you catch errors later (or not at all,
a user might find them instead) and there's more overhead, but good because it lets you do things that
you wouldn't be able to do otherwise. the book talks a lot about the "interior mutability pattern" in relation to this.

you can combine Rc and RefCell to have multiple owners of mutable data. careful though because
this can lead to reference cycles.

to avoid this, you can use Rc::downgrade instead of Rc::clone
this gives you a Weak<T>
"the difference is the weak_count doesn't need to be 0 for the Rc<T> instance to be cleaned up."

so i think it's the case that if i see RefCell, i should think: "this field gets mutated
in ways that the compiler can't check the safety of statically."

the book puts it this way: "The RefCell<T> type with its interior mutability gives us a type
that we can use when we need an immutable type but need to change an inner value of that type;
it also enforces the borrowing rules at runtime instead of compile time."

====

2/8/19

so i'm noticing something in implementing 6

i want to use the name "location" here, because it's short but clear

but i'm worried about polluting the global namespace with a vague name, and so
i'm calling it DangerLocation, and having functions with names like `initialize_danger_location_grid()`
instead of `initialize_grid()`, etc.

i think that this is a smell that means that i should be using modules!

DONE after 6b: consider splitting each solution out into its own module + file,
and having a "utils" module for now with shared functions like frequencies

yeah that's definitely the right thing to do

have a binary crate and a lib crate

DONE rename DangerLocation and LocationGrid and etc back to less-specific names once we have that six namespace

====

2/9/19

where's my snowpocalypse?

so the concurrency chapter is talking about channels and mutexes

it's not obvious to me which is the right approach for parallelizing 5b,
they seem pretty equivalent in this case, and channels seem to have a nicer api for what i'm imagining

the section on RefCell<T>/Rc<t> vs Mutex<T>/Arc<T> is interesting
"In the same way we used RefCell<T> to allow us to mutate contents inside an Rc<T>,
we use Mutex<T> to mutate contents inside an Arc<T>."

i think i'll start with channels for 5b, then google to see what rayon is, i've heard it's relevant

ok cool chapter 16 done, let's do this

ok initial naive channel-based implementation gets us from 7.6 seconds to 4.2!
still lots of room for improvement and i'm sure i did this in a clumsy way, but that's cool!