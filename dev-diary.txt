2/4/19

at long last, chapter 13 is behind me and i'm about ready to start

reading through https://doc.rust-lang.org/std/iter/trait.Iterator.html before i begin

the bit about using collect() to collect a list of Results into a Result of lists is interesting

btw here are the vim keybinds i've set up that i need to remember

gd - go to definition
gs - go to definition in a split
,gd - look up documentation
C-x C-o - completion (could this work with C-p instead?)

useful-looking methods aside from the usual FP ones:
* partition
* inspect
* filter_map
* by_ref
* all, any
* find
* find_map
* position, rposition
* max_by_key, max_by, min_by_key, min_by
* rev
* cloned

things i know by different names:
* `flat_map` is clj `mapcat`
* `scan` is clj `reductions`
* `skip` is clj `drop`
* `fold` is clj `reduce`
* `partition` is yelp_lib.iteration `winnow`

things to watch out for:
some of these methods (particularly map, filter, take_while, skip_while, etc)
have this in their documentation (copy-pasting follows):

Because the closure passed to filter() takes a reference, and many iterators iterate over
references, this leads to a possibly confusing situation, where the type of the closure is a double reference.

```
let a = [0, 1, 2];

let mut iter = a.into_iter().filter(|x| **x > 1); // need two *s!

assert_eq!(iter.next(), Some(&2));
assert_eq!(iter.next(), None);
```

so let's just keep an eye out for that.

TODO read through https://doc.rust-lang.org/std/index.html

ok here goes

1a: sum all the numbers

pretty straightforward

1b is straightforward too but i'm confused about this:

let set: HashSet<_> = [1, 2, 3].iter().cloned().collect();
assert_eq!(set.contains(&1), true);
assert_eq!(set.contains(&4), false);

why does set.contains(&1) have to have the &?
TODO ask peter

https://www.forrestthewoods.com/blog/learning-rust-via-advent-of-code/
has a good list of iterator methods and useful crates

mentions https://crates.io/crates/nom and https://crates.io/crates/pest as being
possibly useful for day24

recommends https://github.com/Amanieu/hashbrown

let's try it out!
2x speedup!!

oh wow nice i hadn't tried building in release mode - 0.01 seconds for the whole thing atm

ok so i went through a few rounds of changes for 2b

originally i had this

fn two_b() -> String {
    let contents = fs::read_to_string("src/inputs/2.txt").unwrap();
    let lines: Vec<&str> = contents.lines().collect();

    for (i, line) in lines.iter().enumerate() {
        for other_line in lines.iter().skip(i) {
            let diff_positions = differing_character_positions(line, other_line);
            if diff_positions.iter().count() == 1 {
                let mut ret = String::new();
                for (i, character) in line.chars().enumerate() {
                    if i != diff_positions[0] {
                        ret.push(character);
                    }
                }

                return ret;
            }
        }
    }

    "unreachable".to_string()
}

then i went crazy with iterator methods for fun and got this

fn two_b() -> String {
    let contents = fs::read_to_string("src/inputs/2.txt").unwrap();
    let lines: Vec<&str> = contents.lines().collect();

    let (box_a, box_b) = lines
        .iter()
        .enumerate()
        .flat_map(|(i, line)| {
            lines
                .iter()
                .skip(i)
                .map(move |other_line| (line, other_line))
        })
        .find(|(line, other_line)| {
            differing_character_positions(line, other_line)
                .iter()
                .count()
                == 1
        })
        .unwrap();

    let differing_index = differing_character_positions(box_a, box_b)[0];

    let mut ret = String::new();
    for (i, character) in box_a.chars().enumerate() {
        if i != differing_index {
            ret.push(character);
        }
    }

    return ret;
}

but i was sure that there must be some way to improve that - in particular, the bit where
i was like trying to zip lines against itself (or get, like, a one-way cartesian product?)
felt like it must be implemented in itertools somewhere
and lo and behold, .combinations(2) does exactly what i wanted
except that it puts things in a Vec, so i have to put the two strings into a tuple
so i can destructure them later
and then we get this

fn two_b() -> String {
    let contents = fs::read_to_string("src/inputs/2.txt").unwrap();
    let lines: Vec<&str> = contents.lines().collect();

    let (box_a, box_b) = lines
        .iter()
        .combinations(2)
        .map(|pair| (pair[0], pair[1]))
        .find(|(box_a, box_b)| {
            differing_character_positions(box_a, box_b)
                .iter()
                .count()
                == 1
        })
        .unwrap();

    let differing_index = differing_character_positions(box_a, box_b)[0];

    let mut ret = String::new();
    for (i, character) in box_a.chars().enumerate() {
        if i != differing_index {
            ret.push(character);
        }
    }

    return ret;
}

i still feel like the bit at the end where we make a string that's got all the chars
except for one at a particular index must be improvable somehow, but it's not obvious to me how

eh, it turns out this does the trick:

    box_a
        .chars()
        .enumerate()
        .filter(|(i, _)| *i != differing_index)
        .map(|(_, character)| character)
        .collect::<String>()

but the forloop approach is simpler so i'll stick with that.
